---
title: ノード
content_template: templates/concept
weight: 10
---

{{% capture overview %}}

ノードはKubnernetesのワーカマシンです。以前は`minion`と呼ばれていました。ノードはクラスタによって、VMでも物理マシンでも構いません。各ノードは[Pod](/docs/concepts/workloads/pods/pod/)を実行するのに必要なサービスや、マスタコンポネントによって管理されるサービスで構成されます。ノードのサービスには[コンテナランタイム](/docs/concepts/overview/components/#node-components)や、kubelet、kube-proxyなどがあります。詳細はアーキテクチャ設計ドキュメントの[The Kubernetes Node](https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node)の節を参照してください。

{{% /capture %}}

{{< toc >}}

{{% capture body %}}

## ノードステータス {#node-statue}

ノードのステータスは次の情報で構成されます。

* [アドレス](#addresses)
* [状態](#condition)
* [キャパシティ](#capacity)
* [情報](#info)

以下で詳細を述べます。

### アドレス {#addresses}

これらのフィールドの使い方はクラウドプロバイダかベアメタル構成かで異なります。

* HostName: ノードのカーネルによって報告されるホスト名。kubeletの`--hostname-override`パラメータで上書きできる
* ExternalIP: 通常は、外部からルーティング可能な、ノードのIPアドレス (クラスタの外から利用可能)
* InternalIP: 通常は、クラスタ内でのみルーティング可能な、ノードのIPアドレス

### 状態 {#condition}

`conditions`フィールドは`Running`状態のすべてのノードのステータスを表示します。

| ノード状態 | 説明 |
| --------- | ---- |
| `OutOfDisk` | Podを追加するのに十分な空きスペースがノードにない場合は`True`、そうでなければ`False` |
| `Ready` | ノードが正常で、Podを受け入れる準備ができていれば`True`、ノードが正常でなく、Podを受け入れられない場合は`False`、ノードコントローラからノードへの通信が`node-monitor-grace-period` (デフォルトは40秒) 行われなければ`Unknown` |
| `MemoryPressure` | ノードのメモリが圧迫されていれば`True`、そうでなければ`False` |
| `PIDPressure` | ノードで実行するプロセスが多すぎれば`True`、そうでなければ`False` |
| `DiskPressure` | ノードのディスクサイズが圧迫されていれば`True`、そうでなければ`False` |
| `NetworkUnavailable` | ノードのネットワークが適切に構成されていなければ`True`、そうでなければ`False` |
| `ConfigOK` | kubeletが適切に構成されていれば`True`、そうでなければ`False` |

ノードの状態はJSONオブジェクトで表現されます。例えば、正常なノードであれば、次のようなレスポンスが返ってきます。

```json
"conditions": [
  {
    "type": "Ready",
    "status": "True"
  }
]
```

`pod-eviction-timeout`を過ぎても、Ready状態のステータスが`Unknown`や`False`のままであれば、引数が[kube-controller-manager](/docs/admin/kube-controller-manager/)に渡され、ノードコントローラによって、そのノードのすべてのPodが削除されるようスケジューリングされます。デフォルトの退去タイムアウト時間は **5分** です。ノードに到達不能な場合、APIサーバはそのノードのkubeletと通信できません。Podを削除する決定は、APIサーバと再接続されるまで、kubeletへ伝達されません。その間に、削除するようスケジュールされたPodは分割されたノードで実行し続けます。

Kubenetes 1.5より前では、ノードコントローラはこれらのAPIサーバから到達不能なPodを[強制削除](/docs/concepts/workloads/pods/pod/#force-deletion-of-pods)していました。1.5以降では、ノードコントローラは実行が終了したことを確認するまでPodの強制削除を行わなくなりました。到達不能なノードで実行しているPodは、`Terminating`や`Unknown`状態として見られます。ノードが永久にクラスタから除外されたのかどうかをKubernetesが推測できない場合、クラスタ管理者が手動でノードオブジェクトを削除する必要があるかもしれません。Kubernetesからノードオブジェクトを削除することで、そのノードで実行しているすべてのPodオブジェクトはAPIサーバから削除され、その名前が解放されます。

1.12では、`TaintNodesByCondition`機能がベータに昇格したので、ノードライフサイクルコントローラが自動的に条件を表現する[汚染](/ja/docs/concepts/configuration/taint-and-toleration/)を作成します。同様に、スケジューラはノードを考慮するときに条件を無視し、かわりにノードの汚染とPodの耐性を見ます。

ここで、ユーザは古いスケジューリングモデルか、新しいより柔軟なスケジューリングモデルを選ぶことができます。耐性を持たないPodは古いモデルに従ってスケジュールされますが、特定のノードの汚染に耐性を持つPodはそのノードにスケジュールされることがあります。

{{< caution >}}
**注意:** この機能を有効にすることで、条件の監視と汚染の作成の間に多少の遅延が発生します。この遅延は通常1秒未満ですが、正常にスケジュールされたもののkubeletに拒絶されるPodの数が増える可能性があります。
{{< /caution >}}

### キャパシティ {#capacity}

そのノードで利用可能なリソースを表現します。CPUやメモリ、そのノードにスケジュール可能なPodの最大数などがあります。

### 情報 {#info}

カーネルバージョンやKubernetesバージョン (kubeletとkube-proxyのバージョン)、Dockerのバージョン、OS名といった、そのノードについての一般的な情報です。情報はノードからkubeletによって収集されます。

## 管理 {#management}

[Pod](/docs/concepts/workloads/pods/pod/)や[Service](/docs/concepts/services-networking/service/)と違い、ノードは本質的にKubernetesによって作られるものではありません。Google Compute Engineのようなクラウドプロバイダによって作成されたり、物理マシンや仮想マシンのプールに存在していたりします。したがって、Kubernetesがノードを作成する場合、ノードを表現するオブジェクトを作成します。作成後、Kuberentesはノードが妥当かどうかを検証します。例えば、以下の内容でノードを作成したとします。

```json
{
  "kind": "Node",
  "apiVersion": "v1",
  "metadata": {
    "name": "10.240.79.157",
    "labels": {
      "name": "my-first-k8s-node"
    }
  }
}
```

Kubernetesはノードオブジェクトを内部的に作成し、`metadata.name`フィールドに基づいたヘルスチェックにより、ノードを検査します。ノードが妥当、すなわち、必要なすべてのサービスが起動していれば、Podを実行するのに適格であると判断されます。そうでなければ、妥当になるまで、あらゆるクラスタの動作から無視されます。

{{< note >}}
**メモ:** Kubernetesは無効なノードのオブジェクトを保持しつづけ、妥当になったかどうかをチェックしつづけます。このプロセスを止めるためには、ノードオブジェクトを明示的に削除しなければなりません。
{{< /note >}}

現在、Kubernetesノードインタフェースとやりとりするコンポーネントが3つあります。ノードコントローラ、kubelet、kubectlです。

### ノードコントローラ {#node-controller}

ノードコントローラはノードの様々な側面を管理する、Kubenetesマスタコンポーネントです。

ノードコントローラはノードの一生で複数の役割を果たします。最初は、登録された時にCIDRブロックを割り当てることです。

2つ目は、ノードコントローラのノードの内部リストと、クラウドプロバイダで利用可能なマシンのリストを最新に保つことです。クラウド環境で実行する場合、ノードが異常になるとすぐに、ノードコントローラはクラウドプロバイダにそのノードのVMがまだ利用可能かどうかを問い合わせます。利用可能でなければ、ノードコントローラはノードリストからそのノードを削除します。

3つ目は、ノードの状態を監視することです。ノードが到達不能になった場合 (例えば、ノードがダウンしたなどで、ノードコントローラがハートビートの受信と停止するなど)、ノードコントローラはNodeStatueのNodeReady状態をConditionUnknownに更新し、その後、ノードが到達不能のままであれば、ノードからPodを退去させる責任を負っています。(デフォルトのタイムアウトはConditionUnknownを受け取ってから40秒で、5分後にPodの退去を開始します。) ノードコントローラは各ノードの状態を`--node-monitor-period`秒ごとにチェックします。

Kubernetes 1.4では、(マスタがネットワークの問題を抱えているために) 多くのノードがマスタへの到達に問題を抱えている場合の扱いを改善するよう、ノードコントローラのロジックを更新しました。1.4から、Podの退去についての判断を行う場合、ノードコントローラはクラスタのすべてのノードの状態を見ます。

ほとんどの場合、ノードコントローラは退去レートを1秒あたり`--node-eviction-rate` (デフォルトは0.1) 、すなわち10秒に1ノードを超えてPodの退去がされないように制限します。

あるアベイラビリティゾーンのノードが異常になった場合、ノード退去のふるまいが変わります。ノードコントローラは、ゾーン内の異常 (NodeReady状態がConditionUnknownまたはConditionFalse) なノードが何パーセントあるかをチェックします。異常なノードの比率が少なくとも`--unhealthy-zone-threshold` (デフォルトは0.55) であれば、退去レートを減らします。クラスタが小さければ (すなわち、`--large-cluster-size-threshold`ノード (デフォルトは50) 以下であれば) 退去は停止し、そうでなければ退去レートは1秒あたり`--secondary-node-eviction-rate` (デフォルトは0.01) に減ります。アベイラビリティゾーンごとにこれらのポリシを採用する理由は、あるアベイラビリティゾーンが、他は接続したままであるのにマスタから分離されてしまう可能性があるためです。クラスタがクラウドプロバイダの複数のアベイラビリティゾーンにまたがっていなければ、アベイラビリティゾーンは1つしかありません。

ノードがアベイラビリティゾーンをまたがって広がる主な理由は、1つのゾーン全体がダウンした場合でも、ワークロードを正常なゾーンに移動できるためです。そのため、1つのゾーンのすべてのノードが異常になると、ノードコントローラは通常のレートである`--node-eviction-rate`で退去を行います。難しいケースは、すべてのゾーンが完全に異常になった場合 (すなわち、正常なノードがクラスタにいなくなる場合) です。このような場合、ノードコントローラは、何らかのマスタ接続に関する問題が発生していると推測し、いくつかの接続が回復するまですべての退去を停止します。

Kubernetes 1.6から、ノードコントローラは、`NodeExcecute`汚染を持つノードで実行している耐性を持たないPodの退去にも責任を持つようになりました。加えて、デフォルトで無効になるアルファ機能として、ノードコントローラは、ノードの到達不能や準備未完了のようなノードの問題に対応する汚染を追加する責任も負います。`NoExecute`汚染とアルファ機能についての詳細は[このドキュメント](/ja/docs/concepts/configuration/taint-and-toleration/)を参照してください。

バージョン1.8から、ノードコントローラはノード状態を表現する汚染の作成に対する責任を持つようにできます。これはバージョン1.8のアルファ機能です。

### ノードの自己登録 {#self-registration-of-nodes}

kubeletのフラグ `--register-node`がtrueの場合 (これがデフォルト)、kubeletは自身をAPIサーバに登録しようとします。多くの場合、これが望ましいパターンです。

kubeletは自己登録を次のオプションで開始します。

  - `--kubeconfig` - APIサーバへの認証に使う、自身の資格情報へのパス
  - `--cloud-provider` - 自身についてのメタデータを読み込むためにクラウドプロバイダとやりとりする方法
  - `--register-node` - APIサーバに自動で登録する
  - `--register-with-taints` - 与えられた汚染を付与してノードを登録する (カンマ区切りの `<key>=<value>:<effect>`。`register-node`がfalseなら何もしない
  - `--node-ip` - ノードのIPアドレス
  - `--node-labels` - 登録するノードに追加するラベル
  - `--node-status-update-frequency` - どれくらいの頻度でノードステータスをマスタにポストするか指定する

現在、kubeletはあらゆるノードリソースの作成/編集をする認可を得ていますが、実際には自身のみを作成/編集します。(将来、kubeletは自身のノードリソースのみを変更できるようにする予定です。)

#### 手動でのノード管理 {#manual-node-administration}

クラスタ管理者はノードオブジェクトの作成と編集ができます。

管理者が手動でノードオブジェクトを作成したいのであれば、kubeletのフラグを`--register-node=false`に設定します。

管理者はノードリソースの編集ができます (`--register-node`の設定にかかわらず)。編集にはノードのラベルの設定と、スケジュール不可にすることも含まれます。

ノードのラベルは、スケジューリングを制御するPodのノードセレクタと結合するために使われます。例えば、Podを実行するノードを適格なもののみに制限するためなどです。

スケジュール不可とノードをマークすることで、そのノードに新しいPodがスケジュールされることを防ぎますが、既にそのノードに存在しているPodには影響がありません。これはノード再起動前などの準備段階に便利です。例えば、ノードをスケジュール不可とマークするためには、次のコマンドを実行します。

```shell
kubectl cordon $NODENAME
```

{{< note >}}
**メモ:** DaemonSetコントローラによって作成されたPodはKubernetesスケジューラをバイパスし、ノードのスケジュール不可属性を考慮しません。デーモンは、再起動の準備としてアプリケーションを退避させたとしても、マシンに属すると考えられるためです。
{{< /note >}}

### ノードキャパシティ {#node-capacity}

ノードのキャパシティ (CPU数とメモリ量) はノードオブジェクトの一部です。通常、ノードは自身と登録し、ノードオブジェクトを作成する時にそのキャパシティを報告します。[手動でのノード管理](#manual-node-administration)を行うのであれば、ノードを追加する時にノードキャパシティを設定する必要があります。

Kubernetsスケジューラはノード上のすべてのPodに対して十分なリソースがあることを保証します。ノード上のコンテナの要求の合計がノードキャパシティを超えないかチェックします。kubeletによって起動されるすべてのコンテナを含みますが、[コンテナランタイム](/docs/concepts/overview/components/#node-components)によって直接起動されたり、コンテナの外側で実行されるプロセスは含まれません。

非Podのプロセスに対して明示的にリソースを予約したい場合、Placeholder Podを作成できます。次のようなテンプレートを使います。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: resource-reserver
spec:
  containers:
  - name: sleep-forever
    image: k8s.gcr.io/pause:0.8.0
    resources:
      requests:
        cpu: 100m
        memory: 100Mi
```

`cpu`と`memory`の値に、予約したいリソース量を設定してください。このファイルをマニフェストディレクトリ (kubeletの`--config=DIR`フラグで指定) に置きます。リソースを予約したい場所にある各kubeletでこれを行ってください。

## APIオブジェクト {#api-object}

ノードはKubernetes REST APIのトップレベルリソースです。APIオブジェクトの詳細は[Node API object](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#node-v1-core)を参照してください。

{{% /capture %}}
