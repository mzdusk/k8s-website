---
title: Kubernetesとは
content_template: templates/concept
weight: 10
---

{{% capture overview %}}
このページではKubernetesの概要を説明します。
{{% /capture %}}

{{% capture body %}}
Kubernetesは、宣言的な構成と自動化の両方を容易にする、コンテナ化されたワークロードやサービスを管理する、ポータブルで拡張可能なオープンソースプラットフォームです。巨大で急速に成長するエコシステムを持っています。Kubernetesのサービスやサポート、ツールは幅広く利用可能です。

Googleは2014年にKubernetesプロジェクトをオープンソース化しました。Kubernetesは[Googleの十数年の経験](https://research.google.com/pubs/pub43438.html)の上に構築されており、コミュニティからの最善アイデアと活動と組み合わされています。

## なぜKubernetesが必要で、何をしてくれるのか？ {#why-do-i-need-kubernetes-and-what-can-it-do}

Kubernetesには多くの機能があります。以下のように考えられています。

- コンテナプラットフォーム
- マイクロサービスプラットフォーム
- ポータブルクラウドプラットフォーム
など。

Kubernetesは **コンテナ中心** の管理環境を提供します。これはユーザのワークロードのかわりに、コンピューティング、ネットワーキング、ストレージインフラを統合します。これはPaaS (Platform as a Service)の簡潔さとIaaS (Infrastructure as a Service)の柔軟性を提供し、インフラプロバイダ間の移動を可能にします。

## Kubernetesはどのようなプラットフォームなのか {#how-is-kubernetes-a-platform}

Kubernetesは多くの機能を提供しますが、新しい機能から恩恵を受ける新しいシナリオが常にあります。アプリケーション固有のワークロードは開発の速度を加速するために合理化されるべきです。初期には許容されるアドホックなオーケストレーションは、スケールするにしたがって堅牢な自動化が必要になります。これが、Kubernetesがアプリケーションのデプロイ、スケール、管理を容易にするコンポーネントとツールのエコシステムを構築するためのプラットフォームとして設計された理由でもあります。

[ラベル](/docs/concepts/overview/working-with-objects/labels/)はユーザがリソースを整理できるようにするためのものです。[アノテーション](/docs/concepts/overview/working-with-objects/annotations/)はリソースのワークフローを容易にし、管理ツールに状態をチェックする簡単な方法を提供するためのカスタム情報をリソースに付加できます。

加えて、[Kubernetesコントロールプレーン](/docs/concepts/overview/components/)は開発者とユーザが利用できるものと同じ[APIs](/docs/reference/using-api/api-overview/)上に構築されています。ユーザは一般的な目的の[コマンドラインツール](/docs/user-guide/kubectl-overview/)が対象とするような[自身のAPI](/docs/concepts/api-extension/custom-resources/)を持つ[スケジューラ](https://github.com/kubernetes/community/blob/{{< param "githubbranch" >}}/contributors/devel/scheduler.md)のようなオリジナルのコントローラを書くことができます。

この[設計](https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md)により、数多くのシステムがKubernetes上で構築できます。

## Kubernetesは何でないか {#what-kubernetes-is-not}

Kubernetesは伝統的な、全部入りPaaS (Platform as a Service) システムではありません。Kubernetesはハードウェアレベルでなくコンテナレベルの運用を行うので、デプロイやスケーリング、ロードバランシング、ロギング、モニタリングといった一般的にPaaSが提供する機能を提供します。しかしながら、Kubernetesはモノリシックではないので、これらのPaaSではデフォルトのソリューションはオプションでプラガブルです。Kubernetesは開発者プラットフォームを構築するための要素を提供しますが、重要なユーザ選択と柔軟性は保っています。

Kubernetesは、

* サポートするアプリケーションのタイプを制限しません。Kubernetesは、ステートレスなもの、ステートフルなもの、データ処理ワークフローなどを含む、極めて多様なワークロードをサポートすることを主眼においています。コンテナで実行できるアプリケーションであれば、Kubernetes上でうまく動くに違いありません。
* ソースコードをデプロイしたり、アプリケーションをビルドしたりはしません。継続的インテグレーションやデリバリ、デプロイ (CI/CD) のワークフローは、技術的な必要性と同じく組織の文化や好みによって決定されます。
* ミドルウェア (例えばメッセージバス) やデータ処理フレームワーク (例えば Spark)、データベース (例えば mysql)、キャッシュ、組み込みのクラスタストレージシステム (例えば Ceph) のようなアプリケーションレベルのサービスは提供しません。このようなコンポーネントはKubernetes上で実行できますし、Open Service Brokerのようなポータブルな仕組みを通して、Kubernetes上で動くアプリケーションからアクセスできます。
* ロギング、モニタリング、アラーティングソリューションに影響しません。概念実証としていくつかの統合と、メトリクスの収集とエクスポートの仕組みを提供します。
* 構成言語やシステム (例えば[jsonnet](https://github.com/google/jsonnet)) を要求したり提供したりはしません。宣言的な仕様の抽象的な形で受け付ける宣言的なAPIを提供します。
* 総合的なマシン構成やメンテナンス、管理、自己回復システムを提供したり採用したりはしません。

加えて、Kubernetesはただの *オーケストレーションシステム* ではありません。実際、オーケストレーションに対するニーズは取り除いています。*オーケストレーション* の技術的な定義は定義されたワークフローを実行することです。最初にAをして、次にB、その次にCといった具合です。対照的に、Kuberentesは、現在の状態を指定された求める状態にする、独立した、構成可能な制御プロセスの集合で構成されています。どのようにAからCにするのかは問題としません。集権化された制御も必要ありません。これにより、システムをより簡単に使え、より強力に、堅牢に、弾力的に、そして拡張可能にします。

## なぜコンテナなのか？ {#why-containers}

コンテナを使うべき理由を考えてみましょう。

![Why Containers?](/images/docs/why_containers.svg)

アプリケーションをデプロイする *古い方法* はOSのパッケージ管理システムを使ってホストにアプリケーションをインストールすることでした。これは、アプリケーションの実行ファイル、構成、ライブラリ、そしてそれら同士とOSのライフサイクルを巻き込む欠点があります。予測可能なロールアウトとロールバックを達成するために不変の仮想マシンイメージをビルドすることもできますが、VMは重量級でポータブルではありません。

*新しい方法* はハードウェア仮想化ではなく、OSレベル仮想化をベースとしたコンテナをデプロイすることです。これらのコンテナは、お互いとホストから分離しています。自身のファイルシステムを持ち、お互いのプロセスは見えず、計算資源の使用量を制限できます。これらはVMよりも簡単にビルドでき、基になるインフラやホストのファイルシステムから分離されているので、クラウドやOSディストリビューション間でポータブルです。

コンテナは小さくて速いので、1つのアプリケーションを各コンテナイメージに固めることができます。この1対1アプリケーション-イメージ関係はコンテナのすべての利点を解き放ちます。コンテナだと、アプリケーションスタック以外の部分が必要なく、本番のインフラ環境に結び付かないので、不変のコンテナイメージはデプロイ時ではなく、ビルド/リリース時に作成できます。ビルド/リリース時のコンテナイメージの作成は、開発から本番への一貫性のある環境の移行を可能にします。同様に、コンテナはVMよりもかなり透過的で、モニタリングや管理を容易にします。これは特に、コンテナのプロセスライフサイクルがコンテナ内のプロセススーパバイザによって隠されるよりも、インフラによって管理される場合に有効です。最後に、コンテナごとに1つのアプリケーションにすることで、コンテナの管理はアプリケーションのデプロイの管理と同じことになります。

コンテナの利点の概要です。

* **アプリケーションの作成とデプロイの高速化**:
    VMイメージを使う場合と比べて、コンテナイメージ作成はより容易さと効率性が高くなります。
* **継続的デプロイ、インテグレーション、デプロイ**:
    信頼性と (イメージの不変性のため) 素早く簡単なロールバックのある高頻度のコンテナイメージ作成とデプロイを提供します。
* **開発と運用の関心の分離**:
    デプロイ時でなくビルド/リリース時にアプリケーションコンテナイメージを作成するので、アプリケーションとインフラを分離します。
* **観測可能性**:
    表面的なOSレベルの情報とメトリクスだけでなく、アプリケーションの死活や他のシグナルを観測できます。
* **開発、テスト、本番での環境の一貫性**:
    ラップトップとクラウドで同じものを実行できます。
* **クラウドとOSディストリビューションのポータビリティ**:
    Ubuntu, RHEL, CoreOS, オンプレ, Google Kubernetes Engine, その他さまざまな場所で実行できます。
* **アプリケーション中心の管理**:
    仮想ハードウェア上でのOSの実行から、論理的なリソースを使うOS上でのアプリケーションの実行へ抽象度を上げることができます。
* **ゆるやかに結びつき、分散し、弾力性のある、自由な[マイクロサービス](https://martinfowler.com/articles/microservices.html)**:
    アプリケーションは小さな独立した部品に分解され、動的にデプロイ、管理されます。1つの大きな単一目的のマシンで実行する肥大したモノリシックスタックではありません。
* **リソース分離**:
    アプリケーションのパフォーマンスが予測可能になります。
* **リソース利用**:
    高効率で高密度です。

## Kubernetesの意味は？k8sとは？ {#what-does-kubernetes-mean-k8s}

**Kubernetes** という名前は *操舵手* や *パイロット* という意味のギリシャ語からとったもので、*知事* の語源です。*K8s* は中央の "ubernete" を "8" で表した短縮形です。

{{% /capture %}}

{{% capture whatsnext %}}
*   [始める](/docs/setup/)準備はできましたか？
*   詳細は[Kubernetesドキュメント](/ja/docs/home/)を参照してください。
{{% /capture %}}
