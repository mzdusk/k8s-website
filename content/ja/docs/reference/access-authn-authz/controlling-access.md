---
title: Kubernetes APIへのアクセス制御
content_template: templates/concept
weight: 5
---

{{% capture overview %}}
このページではKubernetes APIへのアクセス制御の概要を提供します。
{{% /capture %}}

{{% capture body %}}
ユーザは`kubectl`やクライアントライブラリを使うか、RESTリクエストを作成して
[APIにアクセス](/ja/docs/tasks/access-application-cluster/access-cluster/)します。
[Kubernetesサービスアカウント](/ja/docs/tasks/configure-pod-container/configure-service-account/)で
APIへのアクセスを認証できます。リクエストがAPIに到達すると、次の図に示すようないくつかの段階を経ます。

![Diagram of request handling steps for Kubernetes API request](/images/docs/admin/access-control-overview.svg)

## トランスポートセキュリティ

通常のKubernetesクラスタでは、APIはポート443で提供されます。APIサーバは証明書を提示します。この証明書は
大抵自己署名されているので、ユーザのマシンの`$USER/.kube/config`にAPIサーバの証明書のルート証明書が
含まれていて、これが指定されているとシステムのデフォルトルート証明書のかわりに使われます。この証明書は
通常、`kube-up.sh`でクラスタを作成した時、自動的に`$USER/.kube/config`に書き込まれます。クラスタに
複数のユーザがいる場合、作成者はこの証明書をほかのユーザに共有する必要があります。

## 認証

TLSが確立されると、HTTPリクエストは認証のステップへ移ります。これは図のステップ **1** で示されるものです。
クラスタ作成スクリプトもしくはクラスタ管理者は、1つ以上の認証モジュールを実行するようAPIサーバを構成します。
認証モジュールについては[ここ](/ja/docs/reference/access-authn-authz/authentication/)でより詳細に述べます。

認証ステップへの入力はHTTPリクエスト全体ですが、通常はヘッダとクライアント証明書のみを検査します。

認証モジュールはクライアント証明書やパスワード、プレーントークン、ブートストラップトークン、
(サービスアカウントによって使われる) JWTトークンを含みます。

複数の認証モジュールを指定することができ、この場合、それぞれが成功するまで順番に試行されます。

GCEではクライアント証明書、パスワード、プレーントークン、JWTトークンがすべて有効です。

リクエストが認証できないと、HTTPステータスコード 401で拒絶されます。そうでなければ、ユーザは指定した
`username`として認証され、そのユーザ名は後続のステップでその意思決定のために利用できます。いくつかの認証
モジュールにはユーザのグループも提供しているものもある。

Kubernetesはアクセス制御の決定とリクエストのロギングに`username`を使うが、そのオブジェクトに格納されている
ユーザの他の情報を含む`user`オブジェクトは持ちません。

## 認可

リクエストが特定のユーザから来たものであると認証された後、リクエストは認可されなければなりません。これは図の
ステップ _**2**_ に示されます。

リクエストはリクエストした人のユーザ名やリクエストされたアクション、アクションによって影響があるオブジェクトを
含まなければなりません。既存のポリシがそのユーザにはリクエストされたアクションを完了する権限があると認めれば、
リクエストは認可されます。

例えば、Bobが以下のポリシを持っていれば、`projectCaribou`という名前空間のPodのみを参照することができます。

```json
{
    "apiVersion": "abac.authorization.kubernetes.io/v1beta1",
    "kind": "Policy",
    "spec": {
        "user": "bob",
        "namespace": "projectCaribou",
        "resource": "pods",
        "readonly": true
    }
}
```

Bobが以下のリクエストを作成すると、`projectCaribou`名前空間のオブジェクトの参照は許可されているので、
リクエストは認可されます。

```json
{
  "apiVersion": "authorization.k8s.io/v1beta1",
  "kind": "SubjectAccessReview",
  "spec": {
    "resourceAttributes": {
      "namespace": "projectCaribou",
      "verb": "get",
      "group": "unicorn.example.org",
      "resource": "pods"
    }
  }
}
```

Bobが`projectCaribou`名前空間のオブジェクトに書き込む (`create`もしくは`update`) リクエストを
作成すると、彼の認可は拒否されます。Bobが`projectFish`のような異なる名前空間のオブジェクトを参照
(`get`) するリクエストを作成すると、彼の認可は拒否されます。

Kubernetesの認可は既存の組織レベルやクラウドプロバイダレベルのアクセス制御システムと連携するために、
一般的なREST属性の使用を必要とします。これらの制御システムはKubernetes APIとは別のAPIと連携する
かもしれないので、これはREST形式を利用するのに重要です。

KubernetesはABACモードやRBACモード、Webhookモードといった複数の認可モジュールをサポートします。
管理者がクラスタを作成すると、APIサーバで使われるべき認可モジュールを構成します。複数の認可
モジュールが構成されると、Kubernetesは各モジュールをチェックし、いずれかのモジュールがリクエストを
認可すると、そのリクエストは処理できます。すべてのモジュールがリクエストを拒否すると、リクエスは
拒否されます (HTTPステータスコード403)。

サポートされる認可モジュールを使ったポリシの作成についての詳細を含む、Kubernetesの認可について
さらに学ぶためには[認可の概要](/ja/docs/reference/access-authn-authz/authorization/)を参照してください。

## アドミッション制御

アドミッション制御モジュールはリクエストを修正したり拒否したりできるソフトウェアモジュールです。
認可モジュールで利用可能な属性に加え、アドミッション制御モジュールは作成または更新されるオブジェクトの
内容にアクセスできます。作成、削除、更新、接続(プロキシ)されるオブジェクトに影響を与えますが、参照
することはできません。

複数のアドミッションコントローラを構成することができます。それぞれは順番に呼ばれます。

これは図のステップ **3** で示されます。

認証モジュールや認可モジュールと異なり、いずれかのアドミッションコントローラが拒絶すれば、リクエストは
即座に拒絶されます。

オブジェクトの拒絶に加え、アドミッションコントローラはフィールドに対して複雑なデフォルトを設定することも
できます。

利用可能なアドミッション制御モジュールは
[ここ](/ja/docs/reference/access-authn-authz/admission-controllers/)に記述されています。

一度リクエストがすべてのアドミッションコントローラをパスすれば、対応するAPIオブジェクトの妥当性検査ルーチンを
使って妥当性検査が行われ、オブジェクトストアに書き込まれます (図のステップ **4**)。

## APIサーバポートとIP

前の議論ではAPIサーバのセキュアなポートに送られたリクエストを適用しました (典型的なケース)。APIサーバは
実際には2つのポートで提供できます。

デフォルトでは Kubernetes APIサーバは2つのポートのHTTPで提供されます。

  1. `Localhost Port`:
  
      - テストとブートストラップ目的で、マスタノードの他のコンポーネント (スケジューラ、コントローラマネージャ)
        がAPIとやりとりすることを意図している
      - TLSではない
      - デフォルトはポート8080で、`--insecure-port`フラグで変更できる
      - デフォルトIPはlocalhostで、`--insecure-bind-address`フラグで変更できる
      - リクエストは認証モジュールと認可モジュールを **バイパス** する
      - リクエストはアドミッション制御モジュールによって扱われる
      - ホストアクセスから保護される必要がある
  
  2. `Secure Port`:
  
      - 何時でも利用できる
      - TLSを使う。証明書は`--tls-cert-file`フラグで、鍵は`--tls-private-key-file`フラグで設定する
      - デフォルトはポート6443で、`--secure-port`フラグで変更できる
      - デフォルトIPは1つ目のlocalhostでないネットワークインタフェースで、`--bind-adress`フラグで変更できる
      - リクエストは認証モジュールと認可モジュールによって扱われる
      - リクエストはアドミッション制御モジュールによって扱われる
      - 認証モジュールと認可モジュールを実行する

`kube-up.sh`によってクラスタが作成されると、Google Compute Engine (GCE)やほかのクラウドプロバイダでは、
APIサーバはポート443で提供されます。GCEでは、ファイアウォールルールはAPIへの外部のHTTPSアクセスを許可
するようプロジェクトで構成されます。他のクラスタのセットアップ方法はさまざまです。

{{% /capture %}}
